<!DOCTYPE html>
<html>
<head><title>Multi AI Test</title></head>
<body style="font-family: Arial; padding: 20px; max-width: 800px; margin: 0 auto;">
  <h2>ü§ñ Multi AI Orchestrator Test</h2>
  
  <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
    <div style="padding: 15px; background: #f3e8ff; border-radius: 8px;">
      <h3 style="color: #7c3aed; margin-top: 0;">üß† Orchestrator LLM</h3>
      <input type="password" id="orchestratorKey" style="width: 100%; padding: 8px; margin-bottom: 10px;" placeholder="Gemini API Key">
      <select id="orchestratorModel" style="width: 100%; padding: 8px;">
        <option value="gemini-1.5-flash">gemini-1.5-flash</option>
        <option value="gemini-1.5-pro">gemini-1.5-pro</option>
      </select>
    </div>
    <div style="padding: 15px; background: #dbeafe; border-radius: 8px;">
      <h3 style="color: #2563eb; margin-top: 0;">‚ö° Executor LLM</h3>
      <input type="password" id="executorKey" style="width: 100%; padding: 8px; margin-bottom: 10px;" placeholder="Gemini API Key (can be same)">
      <select id="executorModel" style="width: 100%; padding: 8px;">
        <option value="gemini-1.5-flash">gemini-1.5-flash</option>
        <option value="gemini-1.5-pro">gemini-1.5-pro</option>
      </select>
    </div>
  </div>

  <div style="margin-bottom: 15px;">
    <label><strong>Your Request:</strong></label><br>
    <textarea id="userInput" style="width: 100%; padding: 10px; margin-top: 5px; height: 80px;" placeholder="e.g., Analyze data quality and create a hierarchy for financial reporting">Analyze the data in my Excel file and suggest a hierarchy structure</textarea>
  </div>
  
  <button onclick="testOrchestrator()" style="padding: 12px 24px; background: #7c3aed; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px;">üöÄ Run Multi AI Test</button>
  
  <div style="margin-top: 20px;">
    <h3>üìã Orchestrator Response:</h3>
    <div id="orchestratorResult" style="padding: 15px; background: #faf5ff; border: 1px solid #e9d5ff; border-radius: 5px; white-space: pre-wrap; min-height: 100px;">Waiting...</div>
  </div>
  
  <div style="margin-top: 20px;">
    <h3>üìù Parsed Tasks:</h3>
    <div id="tasksResult" style="padding: 15px; background: #fff7ed; border: 1px solid #fed7aa; border-radius: 5px; min-height: 50px;">Waiting...</div>
  </div>
  
  <div style="margin-top: 20px;">
    <h3>‚ö° Executor Log:</h3>
    <div id="executorResult" style="padding: 15px; background: #1f2937; color: #10b981; border-radius: 5px; font-family: monospace; min-height: 50px;">Waiting...</div>
  </div>

  <script>
    const orchestratorSystemPrompt = `You are an AI Orchestrator for DataBridge AI, a data reconciliation and hierarchy management system.

YOUR ROLE:
- Understand user requests and break them into executable tasks
- Maintain conversation context and track progress
- Coordinate task execution with the Executor LLM

CURRENT CONTEXT:
- Active Data Source: Excel file "sample_data.xlsx"
- Available MCP Tools: load_csv, profile_data, create_hierarchy, query_database, export_hierarchy_csv

AVAILABLE TASK TYPES:
1. MCP_TOOL - Execute an MCP tool
2. QUERY - Run a database query
3. ANALYZE - Analyze data or results

When you need to execute a task, output it in this format:
[TASK]
type: MCP_TOOL
command: tool_name(param1="value1")
description: Brief description
[/TASK]

You can include multiple [TASK] blocks. After describing tasks, provide a brief explanation.`;

    async function callGemini(apiKey, model, systemPrompt, userMessage) {
      const resp = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          contents: [
            { role: 'user', parts: [{ text: systemPrompt }] },
            { role: 'model', parts: [{ text: 'I understand. I am ready to help as the DataBridge AI Orchestrator.' }] },
            { role: 'user', parts: [{ text: userMessage }] }
          ],
          generationConfig: { maxOutputTokens: 2048 }
        })
      });
      const data = await resp.json();
      if (data.error) throw new Error(data.error.message || JSON.stringify(data.error));
      return data.candidates?.[0]?.content?.parts?.[0]?.text || 'No response';
    }

    async function testOrchestrator() {
      const orchKey = document.getElementById('orchestratorKey').value;
      const orchModel = document.getElementById('orchestratorModel').value;
      const execKey = document.getElementById('executorKey').value || orchKey;
      const execModel = document.getElementById('executorModel').value;
      const userInput = document.getElementById('userInput').value;
      
      const orchResult = document.getElementById('orchestratorResult');
      const tasksResult = document.getElementById('tasksResult');
      const execResult = document.getElementById('executorResult');
      
      if (!orchKey) { orchResult.innerHTML = '‚ùå Please enter Orchestrator API key'; return; }
      
      orchResult.innerHTML = '‚è≥ Calling Orchestrator LLM...';
      tasksResult.innerHTML = 'Waiting for orchestrator...';
      execResult.innerHTML = 'Waiting for tasks...';
      
      try {
        // Step 1: Call Orchestrator
        const response = await callGemini(orchKey, orchModel, orchestratorSystemPrompt, userInput);
        orchResult.innerHTML = response;
        
        // Step 2: Parse tasks
        const taskMatches = [...response.matchAll(/\[TASK\]([\s\S]*?)\[\/TASK\]/g)];
        const tasks = [];
        
        for (const match of taskMatches) {
          const taskContent = match[1];
          const typeMatch = taskContent.match(/type:\s*(\w+)/i);
          const commandMatch = taskContent.match(/command:\s*(.+)/i);
          const descMatch = taskContent.match(/description:\s*(.+)/i);
          
          if (typeMatch) {
            tasks.push({
              type: typeMatch[1].trim(),
              command: commandMatch ? commandMatch[1].trim() : '',
              description: descMatch ? descMatch[1].trim() : ''
            });
          }
        }
        
        if (tasks.length === 0) {
          tasksResult.innerHTML = '‚ö†Ô∏è No [TASK] blocks found in response. The orchestrator gave a direct answer.';
        } else {
          tasksResult.innerHTML = tasks.map((t, i) => 
            `<div style="padding: 10px; margin: 5px 0; background: white; border-radius: 4px;">
              <strong>#${i+1} ${t.type}</strong><br>
              <code>${t.command}</code><br>
              <small>${t.description}</small>
            </div>`
          ).join('');
        }
        
        // Step 3: Execute tasks (simulated)
        execResult.innerHTML = '';
        for (const task of tasks) {
          execResult.innerHTML += `[${new Date().toLocaleTimeString()}] Executing: ${task.type}\n`;
          execResult.innerHTML += `  Command: ${task.command}\n`;
          execResult.innerHTML += `  ‚úì Completed (simulated)\n\n`;
        }
        
        if (tasks.length === 0) {
          execResult.innerHTML = 'No tasks to execute - orchestrator provided direct response.';
        }
        
      } catch (e) {
        orchResult.innerHTML = '‚ùå Error: ' + e.message;
      }
    }
  </script>
</body>
</html>
