"""
Git Automation MCP Tools for DataBridge AI.

Provides tools for:
- Committing generated dbt projects
- Creating deployment PRs
- Committing SQL deployment scripts
"""

import json
import logging
from pathlib import Path
from typing import Optional
from datetime import datetime, timezone

from fastmcp import FastMCP

logger = logging.getLogger(__name__)


def register_git_tools(mcp: FastMCP) -> None:
    """Register git automation tools with the MCP server."""

    @mcp.tool()
    def commit_dbt_project(
        project_id: str,
        branch_name: Optional[str] = None,
        commit_message: Optional[str] = None,
        author: Optional[str] = None,
    ) -> dict:
        """
        Generate a dbt project and commit it to a new git branch.

        This tool:
        1. Generates dbt models from the hierarchy project
        2. Creates a new branch (auto/dbt-{project_id}-{timestamp})
        3. Commits the generated files
        4. Optionally pushes to remote

        Args:
            project_id: Hierarchy project UUID to generate dbt from.
            branch_name: Custom branch name (default: auto/dbt-{project_id}).
            commit_message: Custom commit message.
            author: Git author string (format: "Name <email>").

        Returns:
            JSON with commit details including branch, sha, and files.

        Example:
            commit_dbt_project(
                project_id="abc123",
                branch_name="feature/dbt-financial-reporting"
            )
        """
        try:
            from databridge_core.git import GitOperations, GitOperationError
        except ImportError:
            return {
                "error": "Git operations module not available",
                "hint": "Install databridge-core with git support",
            }

        try:
            # Get repo path (assume we're in repo root or find it)
            repo_path = _find_repo_root()
            if not repo_path:
                return {
                    "error": "Not in a git repository",
                    "hint": "Run from within the DataBridge AI repository",
                }

            git = GitOperations(repo_path)

            # Generate branch name if not provided
            if not branch_name:
                timestamp = datetime.now(timezone.utc).strftime("%Y%m%d-%H%M%S")
                branch_name = f"auto/dbt-{project_id[:8]}-{timestamp}"

            # Generate default commit message
            if not commit_message:
                commit_message = f"feat: Generate dbt project for {project_id[:8]}\n\nAuto-generated by DataBridge AI MCP"

            # Check for clean working directory
            status = git.get_status()
            if not status["clean"]:
                return {
                    "error": "Working directory has uncommitted changes",
                    "staged": status["staged"],
                    "modified": status["modified"],
                    "hint": "Commit or stash changes before generating dbt project",
                }

            # Generate dbt project (placeholder - integrate with generation tools)
            dbt_output_dir = repo_path / "generated" / "dbt" / project_id[:8]
            dbt_files = _generate_dbt_project(project_id, dbt_output_dir)

            if not dbt_files:
                return {
                    "error": "No dbt files generated",
                    "project_id": project_id,
                    "hint": "Verify project has hierarchies with source mappings",
                }

            # Create branch
            original_branch = git.get_current_branch()
            git.create_branch(branch_name)

            try:
                # Commit files
                result = git.commit_files(
                    files=dbt_files,
                    message=commit_message,
                    author=author,
                )

                return {
                    "status": "committed",
                    "branch": result.branch,
                    "sha": result.sha,
                    "files_changed": result.files_changed,
                    "dbt_output_dir": str(dbt_output_dir),
                    "files": [str(f) for f in dbt_files[:10]],  # Limit output
                    "original_branch": original_branch,
                    "next_steps": [
                        f"Push branch: git push -u origin {branch_name}",
                        "Create PR: use create_deployment_pr tool",
                    ],
                }

            except GitOperationError as e:
                # Restore original branch on error
                git.switch_branch(original_branch)
                raise

        except GitOperationError as e:
            return {
                "error": str(e),
                "stderr": e.stderr if hasattr(e, "stderr") else "",
            }
        except Exception as e:
            logger.exception("Error committing dbt project")
            return {"error": str(e)}

    @mcp.tool()
    def create_deployment_pr(
        title: str,
        body: Optional[str] = None,
        branch_name: Optional[str] = None,
        base_branch: Optional[str] = None,
        draft: bool = False,
    ) -> dict:
        """
        Create a pull request for a deployment branch.

        This tool:
        1. Pushes the current/specified branch to remote
        2. Creates a PR using GitHub CLI

        Requires:
        - GitHub CLI (gh) to be installed and authenticated
        - A remote repository configured

        Args:
            title: PR title (under 70 characters recommended).
            body: PR description/body. If not provided, generates a default.
            branch_name: Branch to create PR from (default: current branch).
            base_branch: Target branch for PR (default: main/master).
            draft: Create as draft PR.

        Returns:
            JSON with PR details including number, URL, and branches.

        Example:
            create_deployment_pr(
                title="Deploy Q4 2024 P&L hierarchy",
                body="## Changes\\n- Added revenue breakdown\\n- Updated cost mappings"
            )
        """
        try:
            from databridge_core.git import GitOperations, GitOperationError
        except ImportError:
            return {
                "error": "Git operations module not available",
                "hint": "Install databridge-core with git support",
            }

        try:
            repo_path = _find_repo_root()
            if not repo_path:
                return {
                    "error": "Not in a git repository",
                    "hint": "Run from within the DataBridge AI repository",
                }

            git = GitOperations(repo_path)

            # Check gh authentication
            if not git.is_gh_authenticated():
                return {
                    "error": "GitHub CLI not authenticated",
                    "hint": "Run 'gh auth login' to authenticate",
                }

            # Check for remote
            if not git.has_remote():
                return {
                    "error": "No remote repository configured",
                    "hint": "Add remote with: git remote add origin <url>",
                }

            # Use current branch if not specified
            head_branch = branch_name or git.get_current_branch()
            target_base = base_branch or git.get_default_branch()

            # Generate default body if not provided
            if not body:
                body = f"""## Summary
- Deployment branch: `{head_branch}`
- Target: `{target_base}`

## Changes
Auto-generated deployment PR by DataBridge AI.

## Test Plan
- [ ] Review generated SQL/dbt files
- [ ] Validate schema compatibility
- [ ] Run dbt tests if applicable

---
Generated with DataBridge AI MCP
"""

            # Push branch first
            git.push_branch(head_branch, set_upstream=True)

            # Create PR
            result = git.create_pull_request(
                title=title,
                body=body,
                base=target_base,
                head=head_branch,
                draft=draft,
            )

            return {
                "status": "created",
                "pr_number": result.number,
                "url": result.url,
                "title": result.title,
                "head": result.head,
                "base": result.base,
                "draft": draft,
            }

        except GitOperationError as e:
            return {
                "error": str(e),
                "stderr": e.stderr if hasattr(e, "stderr") else "",
            }
        except Exception as e:
            logger.exception("Error creating deployment PR")
            return {"error": str(e)}

    @mcp.tool()
    def commit_deployment_scripts(
        project_id: str,
        scripts: dict,
        branch_name: Optional[str] = None,
        commit_message: Optional[str] = None,
    ) -> dict:
        """
        Commit SQL deployment scripts to a branch.

        Writes provided SQL scripts to files and commits them. Useful for
        committing generated INSERT, VIEW, or MERGE scripts.

        Args:
            project_id: Hierarchy project UUID.
            scripts: Dictionary of script_name -> script_content.
                     Example: {"insert.sql": "INSERT INTO...", "view.sql": "CREATE VIEW..."}
            branch_name: Custom branch name (default: auto/deploy-{project_id}).
            commit_message: Custom commit message.

        Returns:
            JSON with commit details and file paths.

        Example:
            commit_deployment_scripts(
                project_id="abc123",
                scripts={
                    "hierarchy_insert.sql": "INSERT INTO HIERARCHY_MASTER...",
                    "hierarchy_view.sql": "CREATE OR REPLACE VIEW V_HIERARCHY..."
                }
            )
        """
        try:
            from databridge_core.git import GitOperations, GitOperationError
        except ImportError:
            return {
                "error": "Git operations module not available",
                "hint": "Install databridge-core with git support",
            }

        if not scripts:
            return {
                "error": "No scripts provided",
                "hint": "Provide scripts dict with filename -> content mapping",
            }

        try:
            repo_path = _find_repo_root()
            if not repo_path:
                return {
                    "error": "Not in a git repository",
                    "hint": "Run from within the DataBridge AI repository",
                }

            git = GitOperations(repo_path)

            # Generate branch name if not provided
            if not branch_name:
                timestamp = datetime.now(timezone.utc).strftime("%Y%m%d-%H%M%S")
                branch_name = f"auto/deploy-{project_id[:8]}-{timestamp}"

            # Generate default commit message
            if not commit_message:
                script_names = ", ".join(scripts.keys())
                commit_message = f"feat: Add deployment scripts for {project_id[:8]}\n\nScripts: {script_names}"

            # Create output directory
            scripts_dir = repo_path / "generated" / "scripts" / project_id[:8]
            scripts_dir.mkdir(parents=True, exist_ok=True)

            # Write scripts to files
            written_files = []
            for filename, content in scripts.items():
                file_path = scripts_dir / filename
                file_path.write_text(content, encoding="utf-8")
                written_files.append(file_path)
                logger.info(f"Wrote script: {file_path}")

            # Check if we need to create a new branch
            current_branch = git.get_current_branch()
            if current_branch != branch_name:
                if git.branch_exists(branch_name):
                    git.switch_branch(branch_name)
                else:
                    git.create_branch(branch_name)

            # Commit files
            result = git.commit_files(
                files=written_files,
                message=commit_message,
            )

            return {
                "status": "committed",
                "branch": result.branch,
                "sha": result.sha,
                "files_changed": result.files_changed,
                "scripts_dir": str(scripts_dir),
                "files": [str(f.name) for f in written_files],
                "next_steps": [
                    f"Push branch: git push -u origin {branch_name}",
                    "Create PR: use create_deployment_pr tool",
                ],
            }

        except GitOperationError as e:
            return {
                "error": str(e),
                "stderr": e.stderr if hasattr(e, "stderr") else "",
            }
        except Exception as e:
            logger.exception("Error committing deployment scripts")
            return {"error": str(e)}

    @mcp.tool()
    def get_git_status() -> dict:
        """
        Get current git repository status.

        Returns information about the current branch, staged files,
        modified files, and untracked files.

        Returns:
            JSON with repository status including branch name and file lists.

        Example:
            get_git_status()
            # Returns: {"branch": "main", "staged": [], "modified": ["file.py"], ...}
        """
        try:
            from databridge_core.git import GitOperations, GitOperationError
        except ImportError:
            return {
                "error": "Git operations module not available",
                "hint": "Install databridge-core with git support",
            }

        try:
            repo_path = _find_repo_root()
            if not repo_path:
                return {
                    "error": "Not in a git repository",
                    "hint": "Run from within the DataBridge AI repository",
                }

            git = GitOperations(repo_path)
            status = git.get_status()

            # Add additional info
            status["repo_path"] = str(repo_path)
            status["has_remote"] = git.has_remote()
            status["gh_authenticated"] = git.is_gh_authenticated()
            status["default_branch"] = git.get_default_branch()

            return status

        except GitOperationError as e:
            return {
                "error": str(e),
                "stderr": e.stderr if hasattr(e, "stderr") else "",
            }
        except Exception as e:
            logger.exception("Error getting git status")
            return {"error": str(e)}


def _find_repo_root() -> Optional[Path]:
    """Find the git repository root from current directory."""
    current = Path.cwd()

    # Walk up looking for .git
    for parent in [current] + list(current.parents):
        if (parent / ".git").exists():
            return parent

    return None


def _generate_dbt_project(project_id: str, output_dir: Path) -> list:
    """
    Generate dbt project files for a hierarchy project.

    This is a placeholder that should be integrated with the
    generation tools (sql_generator module).

    Args:
        project_id: Hierarchy project UUID.
        output_dir: Directory to write dbt files.

    Returns:
        List of generated file paths.
    """
    output_dir.mkdir(parents=True, exist_ok=True)

    # Placeholder - in real implementation, this would:
    # 1. Load project from HierarchyService
    # 2. Generate dbt models using sql_generator
    # 3. Write dbt_project.yml, models/*.sql, etc.

    files = []

    # Create placeholder dbt_project.yml
    dbt_project = output_dir / "dbt_project.yml"
    dbt_project.write_text(f"""name: 'databridge_{project_id[:8]}'
version: '1.0.0'
config-version: 2

profile: 'databridge'

model-paths: ["models"]
analysis-paths: ["analyses"]
test-paths: ["tests"]
seed-paths: ["seeds"]
macro-paths: ["macros"]
snapshot-paths: ["snapshots"]

clean-targets:
  - "target"
  - "dbt_packages"
""", encoding="utf-8")
    files.append(dbt_project)

    # Create models directory
    models_dir = output_dir / "models"
    models_dir.mkdir(exist_ok=True)

    # Create placeholder model
    placeholder_model = models_dir / f"stg_{project_id[:8]}.sql"
    placeholder_model.write_text(f"""-- Auto-generated by DataBridge AI
-- Project: {project_id}
-- Generated: {datetime.now(timezone.utc).isoformat()}

SELECT
    hierarchy_id,
    hierarchy_name,
    parent_id,
    level_1,
    level_2,
    level_3
FROM {{{{ source('raw', 'hierarchy_master') }}}}
WHERE active_flag = TRUE
""", encoding="utf-8")
    files.append(placeholder_model)

    return files
